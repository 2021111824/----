## 1. GA 

## 2. 约束优化问题 MILP（CPLEX）

## 3. NSGA-II 
是一种**多目标优化算法**。它是遗传算法（GA）的一个变种，特别针对多目标优化问题（MOPs）进行了设计。NSGA-II 通过模拟自然进化过程，结合了非支配排序、拥挤度比较和精英策略，有效地搜索解空间中的**Pareto前沿**（Pareto front），以提供一组多样的、具有高质量的解。  

### NSGA-II的基本流程
#### (1) 初始化种群
随机生成一个初始种群，该种群包含一组解，每个解表示一组决策变量的取值。

#### (2) 评估种群
对每个个体（解）进行**目标函数评估**，计算它们的**适应度**。目标函数根据问题的需求进行定义，通常包含多个目标。

#### (3) 非支配排序
**非支配排序**是NSGA-II的核心思想之一。对于每个个体，NSGA-II根据其在所有目标上的表现将其排序。
* 支配关系：如果个体A在所有目标上都不劣于个体B，并且在至少一个目标上优于个体B，则A支配B。
* 非支配排序：将种群分成若干个不同的“层级”或“等级”（称为“支配层”），每一层包含所有不被其他个体支配的个体。层级越低的个体，表示其在目标空间中的表现越好。

#### (4) 拥挤度计算
对于每个个体，计算它的拥挤度，即该个体与邻近个体的距离（**拥挤度越高**，代表该个体离周围个体**距离越远**）。拥挤度反映了该解在解空间中的分布密度。
* **拥挤度越高，表示个体附近的解越稀疏，解决方案的多样性较好**。
* 拥挤度越低，表示该解的附近有很多其他解，可能会导致多样性较低。  
  
  
**计算过程如下：**

1. **按目标排序**：对每个目标（目标函数）分别对个体进行排序。对于每个目标值，**从小到大**排序个体的索引。

2. **边界个体的距离设置为无穷大**：排序后，**第一个和最后一个个体的拥挤距离设置为无穷大**（`float('inf')`），因为它们位于目标空间的边界位置，无法进一步比较它们的拥挤程度。

3. **中间个体的拥挤距离计算**：对于其他个体（非边界个体），根据其在目标函数上的相邻个体的差异来计算其拥挤距离。具体计算为：
   $$
   \text{拥挤距离} = \frac{f_{i+1} - f_{i-1}}{f_{\text{max}} - f_{\text{min}}}
   $$
   其中，$f_{i+1}$ 和 $f_{i-1}$ 分别是当前个体在目标函数上**相邻的个体**的值，$f_{\text{max}}$ 和 $f_{\text{min}}$ 是该目标上所有个体值的最大值和最小值。

4. **对所有目标重复**：这个过程对**每个目标函数**都进行一次，最后每个个体的拥挤距离是它在**所有目标下的拥挤距离的总和**。

通过这个方法，可以得到每个个体在目标空间中的拥挤程度，值越大说明个体在目标空间中较为稀疏，值越小说明个体较为拥挤。

#### (5) 选择操作（选择父代）
基于非支配排序和拥挤度，通过竞争选择机制从当前种群中选择父代个体。
* 优先选择支配层较高（即解较优的个体）中的个体。
对于同一层的个体，选择拥挤度较大的个体，以保持解的多样性。

#### (6) 交叉与变异
使用传统的遗传算法操作进行交叉（crossover）和变异（mutation），生成新的子代种群。
* 交叉操作用于通过父代的基因重组产生新的解。
* 变异操作用于对个体进行随机扰动，帮助算法跳出局部最优。

#### (7) 合并父代和子代
将父代和子代合并，组成一个更大的候选种群。接下来，通过非**支配排序和拥挤度**比较选择出最好的解，组成新的种群。

#### (8) 选择精英个体
使用**精英策略**，将当前代的优质个体保留到下一代，从而保证最优解不会丢失。

#### (9) 终止条件
算法不断迭代，直到满足终止条件（例如，达到最大代数或目标函数收敛）。
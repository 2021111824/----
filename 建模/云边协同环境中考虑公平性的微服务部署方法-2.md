# 面向公平性的云边微服务系统部署方法
## 1. 概述
随着云端丰富的计算资源以及边缘服务器低延迟特性的不断发展，微服务系统与云-边协同计算已广泛应用于各类场景中。然而，现有的研究主要集中于调整微服务系统部署方案，以最大化整体用户的服务质量体验（QoE），而往往忽略了不同用户之间QoE差异，即公平性问题。这种差异可能导致部分用户的服务质量显著下降，不利于整体用户体验的一致性。 

为了解决这一问题，本文提出了一种新的部署优化方法，**以最小化不同用户之间的响应时间差异为主要优化目标**，从而实现服务的公平性。在此基础上，将**总体响应时间**作为约束条件，确保系统响应在用户可接受范围内。同时，本文以**部署成本**为主要约束，确保方案的经济可行性，并为各个实例节点设定合理的**计算资源限制**，以防止资源超载。

通过这样的优化框架下，我们可以在云边协同环境中实现微服务的公平部署，缩小用户体验差异并满足合理的成本控制和资源约束。这不仅有助于提升用户的整体满意度，还能促进微服务系统在更多场景中的有效应用。

* 要考虑的问题：
  * 服务实例的分布（确保不同位置的用户请求不会因为位置差异而导致显著的响应时间差异）；
  * 负载均衡（通过负载均衡以及智能调度，将用户请求分配到响应最快的服务实例上，避免某些服务因为负载过高而延迟增加）；
  * 资源配置（如计算能力以及内存，避免实例间因性能差异导致响应时间不平衡）。
  * 默认一个边缘节点就是指一个边缘服务器，一个边缘节点上根据资源限制可以部署多个服务实例。
  
## 2. 问题定义
### 2.1 场景描述
作为微服务部署提供商，我们负责为一家全国范围的视频流媒体服务公司设计和优化其服务架构。该公司面向广泛的用户群体，用户分布在不同的城市。

为了实现低延迟的视频播放服务，我们建议采用**云边协同架构**，在各地设置边缘节点，同时在云端整合丰富的计算资源。  

**边缘节点**位于用户附近，可以快速响应用户请求，降低物理传输带来的延迟，但由于各边缘节点的资源（如CPU和内存）有限，负载过高时会导致响应时间增加。**云端**拥有丰富的计算资源，但用户访问云端的延迟较高。因此，公司需要在云端和边缘节点之间合理部署服务实例，以满足响应时间要求，并尽量缩小不同用户间的响应时间差异。 

在此场景中，我们的目标是通过服务实例的智能部署，**最小化不同地区用户之间的响应时间差异**，从而实现用户体验的公平性。与此同时，为了确保用户的整体服务质量体验，将**平均响应时间**作为约束条件，限定在允许的最大范围内。模型中还将控制边缘节点的**部署成本**和**计算资源**负载，以避免边缘节点因超载而影响用户体验。  

通过这样的优化方案，我们希望能够在实现公平性的同时，提升用户的整体满意度，并保证系统的经济可行性和资源的高效使用。



### 2.2 建模
#### 2.2.1 定义变量
a. **用户集 $U$**：  
    $U = \{u_1, u_2, \cdots, u_n\}$，表示所有用户，不同用户可能处于不同的地理位置，位置可用二维坐标 $(x_i,y_i)$ 表示。  

b. **用户优先级 $Q_i$ 及对应权重 $W_i$**：  
  每个用户 $u_i$ 会根据其重要性（如付费用户、普通用户等）赋予一个优先级值 $Q_i$，用户优先级越高，其权重$W_i$越高。（权重越高即其响应时间对整体平均响应时间影响最大，要优先关注权重高的用户的服务质量）

  
c.  **服务集 $S$**：  
    $S = \{s_1, s_2, \cdots, s_m\}$，表示所有可可供用户连接的边缘和云服务器的集合，包含边缘节点 $S_{edge}$ 和云端节点 $S_{cloud}$，位置可用二维坐标 $(x_j,y_j)$ 表示。  
  * 每个服务器上可能部署了一个或多个服务实例。如果没有用户连接到某个服务器，该服务器可以不部署任何服务实例，处于“非活跃”状态。
  服务实例的数量受到服务器资源限制的约束，例如 CPU、内存和带宽。
      
  
d. **请求数据大小** $D_i$：  
    请求数据大小 $D_i$ 是用户 $u_i$ 发往服务器（云或边缘）的数据量。

e. **连接变量 $x_{ij}$**：  
    用二进制变量 $x_{ij}$ 表示用户 $u_i$ 是否连接到边缘或云服务器 $s_j$ 。
$$
x_{ij} = 
\begin{cases} 
  1 & 用户 u_i 连接到服务器 s_j \\
  0 & 用户 u_i 没有连接到服务器 s_j
\end{cases}
$$
  * 满足每个用户连接到唯一的服务器（约束4）
  
  <br />

f.   **响应时间 $t_{ij}$**：  
   用 $t_{ij}$ 表示用户 $u_i$ 连接到服务器 $s_j$ 的响应时间，由两部分组成，$t_{trans_{ij}}$ 和 $t_{proc_{ij}}$ 。
* **传输延迟 $t_{trans_{ij}}$**：  
  表示用户 $u_i$ 到服务器 $s_j$ 的传输延迟，根据服务器是**边缘节点**还是**云节点**有所不同：

  * **边缘节点的传输延迟 $t_{trans_{ij}}^{e}$**：
  $$
  t_{trans_{ij}}^{e} = t_{d_{ij}}^{e} + t_{b_{ij}}^{e}
  $$
  其中：
  
  $$
  t_{d_{ij}}^{e} = \frac {d_{ij}^{e}}{v_e}
  $$  

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  为**物理传输延迟**。$d_{ij}^{e}$ 表示用户 $u_i$ 到边缘节点 $s_j$ 的距离，$v_{e}$ 为边缘节点的网络传播速度。

  <br />

  $$
  t_{b_{ij}}^{e} = \frac {D_i}{b_e(t)}
  $$

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  为**带宽延迟**。${D_i}$ 是用户请求数据的大小，$b_e(t)$ 为边缘节点可用带宽，可能随时间变化。
  <br />
  <br />



  * **云节点的传输延迟 $t_{trans_{ij}}^{c}$**：
  $$
  t_{trans_{ij}}^{c} = t_{d_{ij}}^{c} + t_{b_{ij}}^{c}
  $$
  其中：
  
  $$
  t_{d_{ij}}^{c} = \frac {d_{ij}^{c}}{v_c}
  $$  

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  为**物理传输延迟**。$d_{ij}^{c}$ 表示用户 $u_i$ 到云节点 $s_j$ 的距离，$v_{c}$ 为边缘节点的网络传播速度，因为其物理距离更远，所以通常比边缘节点传播速度低。

  <br />

  $$
  t_{b_{ij}}^{c} = \frac {D_i}{b_c(t)}
  $$

  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
  为**带宽延迟**。${D_i}$ 是用户请求数据的大小，$b_c(t)$ 为云节点可用带宽，可能随时间变化。
  <br />
  <br />

* **处理时间** $t_{proc_{ij}}$：  
   $t_{proc_{ij}}$ 是服务器处理请求的时间，取决于**请求数据大小**和服务器的**处理速率**。处理时间计算也根据**边缘节点和云节点**的不同资源情况有所区别。

    * **边缘节点的处理时间 $t_{proc_{ij}}^{e}$**：
  $$
  t_{proc_{ij}}^{e} = \frac{D_{i}}{P_{j}^{e}} 
  $$

  &nbsp;&nbsp;&nbsp;&nbsp;
  其中，$P_{j}^{e}$ 表示边缘节点 $s_j$ 的处理速率。

    * **云节点的处理时间 $t_{proc_{ij}}^{c}$**：
  $$
  t_{proc_{ij}}^{c} = \frac{D_{i}}{P_{j}^{c}}
  $$

  &nbsp;&nbsp;&nbsp;&nbsp;
  其中，$P_{j}^{c}$ 表示云节点 $s_j$ 的处理速率。

  * 注：由于云节点的资源比边缘节点丰富，则应满足：
  $$
  P_{j}^{c} > P_{j}^{e}
  $$

* **综合响应时间计算**：  
   用户 $u_i$ 连接到服务器 $s_j$ 的响应时间 $t_{ij}$ 为：

   * **若 $s_j$ 位于边缘节点**：
   $$
   t_{ij} = t_{trans_{ij}}^{e} + t_{proc_{ij}}^{e} = \left( t_{d_{ij}}^{e} + t_{b_{ij}}^{e} \right) + t_{proc_{ij}}^{e} = \left( \frac {d_{ij}^{e}}{v_e} + \frac {D_i}{b_e(t)} \right) + \frac{D_{i}}{P_{j}^{e}}
   $$

   * **若 $s_j$ 位于云节点**：
    $$
   t_{ij} = t_{trans_{ij}}^{c} + t_{proc_{ij}}^{c} = \left( t_{d_{ij}}^{c} + t_{b_{ij}}^{c} \right) + t_{proc_{ij}}^{c} = \left( \frac {d_{ij}^{c}}{v_c} + \frac {D_i}{b_c(t)} \right) + \frac{D_{i}}{P_{j}^{c}}
   $$

* **平均响应时间计算**：
$$
\bar{T}= \frac{1}{n} \sum_{i=1}^{n} \sum_{j=1}^{m} x_{ij} \cdot \left( 
\begin{cases}
\left( \frac {d_{ij}^{e}}{v_e} + \frac {D_i}{b_e(t)} \right) + \frac{D_{i}}{P_{j}^{e}}, & s_j \in S_{edge} \\[10pt]
\left( \frac {d_{ij}^{c}}{v_c} + \frac {D_i}{b_c(t)} \right) + \frac{D_{i}}{P_{j}^{c}}, & s_j \in S_{cloud}
\end{cases}
\right)
$$

g. **加权响应时间 $t_{ij}^{weight}$**  
$$
t_{ij}^{weight} = t_{ij} \cdot W_i
$$

i.  **计算资源需求 $R_{i}$**  
用 $R_{i}$ 表示用户 $u_i$连接到服务器 $s_j$时，服务器需要分配的资源来处理视频流的请求。资源需求集合 $R_{i}$ 可定义为：
$$
R_{i} = \{r_{i}^{cpu}, r_{i}^{mem}, r_{i}^{b},  \cdots \}
$$

其中：  
* $r_{i}^{cpu}$ 表示用户 $u_i$连接到服务器 $s_j$时所需的 $CPU$资源量；
* $r_{i}^{mem}$ 表示用户 $u_i$连接到服务器 $s_j$时所需的 内存 资源量；
* $r_{i}^{b}$ 表示用户 $u_i$连接到服务器 $s_j$时所需的 带宽 资源量。

<br />

h.   **部署实例成本 $c_j$**：  
  用 $c_j$ 表示在服务器 $s_j$ 部署服务的成本，由于云节点和边缘节点的差异性，二者的部署成本也有所不同。
  * **边缘节点部署成本** $c_j^e$ ：
  $$
  c_{j}^e = c_{fixed_j}^e + c_{usage_j}^e
  $$
*
  * **固定成本** $c_{fixed_j}^e$ ：用于租赁边缘服务器（每个边缘节点的固定租赁费用）；
 
  * **资源使用成本** $c_{usage_j}^e$ ：是边缘节点在实际运行中产生的资源消耗成本，如 $CPU$、内存和带宽消耗，按资源占用进行计算：
  $$
  c_{usage_j}^e = \sum_{i = 1}^{n} x_{ij} \ \cdot (r_{i}^{cpu} \ \cdot p_{cpu}^{e} + r_{i}^{mem} \ \cdot p_{mem}^{e} + r_{i}^{b} \ \cdot p_{b}^{e})
  $$

  &nbsp;&nbsp;&nbsp;&nbsp;
  其中，$p_{cpu}^{e}$ 、$p_{mem}^{e}$、$p_{b}^{e}$ 分别表示边缘节点上单位 $CPU$、内存和带宽资源的单价；$x_{ij}$ 表示用户 $u_i$是否连接到服务器 $s_j$。

<br />

* **云节点部署成本** $c_j^c$ （云节点通常基于资源使用量付费，可以根据资源消耗量和处理请求数量来计算成本）：
  $$
  c_{j}^c = c_{usage_j}^c + c_{net_j}^c
  $$

*
  * **云资源使用成本** $c_{usage_j}^c$ ：按需计算，包括 $CPU$、内存和带宽使用量。
  $$
  c_{usage_j}^c = \sum_{i = 1}^{n} x_{ij} \ \cdot (r_{i}^{cpu} \ \cdot p_{cpu}^{c} + r_{i}^{mem} \ \cdot p_{mem}^{c} + r_{i}^{b} \ \cdot p_{b}^{c})
  $$

  &nbsp;&nbsp;&nbsp;&nbsp;
  其中，$p_{cpu}^{c}$ 、$p_{mem}^{c}$、$p_{b}^{c}$ 分别表示云节点上单位 $CPU$、内存和带宽资源的单价；$x_{ij}$ 表示用户 $u_i$是否连接到服务器 $s_j$。

  * **网络流量成本** $c_{net_j}^c$ ：用户从不同区域访问云，产生的额外网络传输费用，根据流量数据量计算。
  $$
  c_{net_j}^c = \sum_{i = 1}^{n} x_{ij} \ \cdot D_i \ \cdot p_{net}^{c}
  $$

  &nbsp;&nbsp;&nbsp;&nbsp;
  其中，$p_{net}^{c}$ 为云平台的流量单价，$D_i$ 为用户 $u_i$ 的数据请求的大小。

* **综合部署成本**  
  总部署成本可表示为所有边缘和云节点成本的总和：
  $$
  C_{total} = \sum_{s_j  \in S_{edge}} c_{j}^e   + \sum_{s_j \in S_{cloud}} c_{j}^c  
  $$

### 2.2.2 目标函数（优化公平性）

* **公平性目标函数**：用 $f$ 表示， 即
  $$
  f = min (1 - F_{Jain})
  $$
  其中：
  * $F_{Jain}$ 是Jain公平性指数，定义为：
  $$
  F_{\text{Jain}} = \frac{\left( \sum_{i=1}^{n} t_{ij}^{weight} \right)^2}{n \cdot \sum_{i=1}^{n} \left(t_{ij}^{weight}\right)^2}
  $$
    $t_{ij}^{weight}$ 是加权响应时间，$n$ 是用户总数。

* **作用分析**：
    * **优化公平性**：通过最大化 $F_{Jain}$ ，就是在最小化所有用户的额响应时间差异。当 $F_{Jain}$ 趋近于1时，表示所有用户的响应时间几乎完全相同，系统达到了公平性；而当 $F_{Jain}$ 趋近于0时，说明响应时间差异非常大，系统非常不公平。
    * **公平性评估**：目标函数是最小化 $1 - F_{Jain}$ ,即提高公平性。
    * **不同优先级用户的公平性保证**：引入加权响应时间后，系统能够根据用户优先级调节不同用户之间的响应时间差异，实现对不同优先级用户的“公平性优化”。也就是说，它能保证不同优先级用户的响应时间是公平的。
      

### 2.2.3 约束条件
#### 约束1：不同优先级用户的平均响应时间约束
为每个优先级类别的用户设定一个不同的最大允许的平均响应时:  

$$
\frac{1}{|U_{Q_i}|} \sum_{u_j \in U_{Q_i}} \sum_{s_k \in S} x_{jk} \cdot t_{jk} \leq T_{Q_i}^{max}, \quad \forall Q_i
$$
$T_{Q_i}^{max}$ 是优先级类别 $Q_i$ 的最大响应时间上限。这个约束确保每个优先级类别的用户响应时间不会超过设定的上限。

#### 约束2：部署成本
* 用 $C_{edge}$ 表示边缘节点的总预算，用 $C_{cloud}$ 表示云端的总预算。两者的总和不得超过服务提供商的整体预算 $C_{max}$ 。


  $$
  C_{edge}  + C_{cloud}  =  \sum_{s_j \in S_{edge}} c_j^e + \sum_{s_j \in S_{cloud}} c_j^c \leq C_{max}
  $$
  
  其中，$S_{edge}$ 为所有边缘节点集合，$S_{cloud}$ 为云端节点集合，$c_j$ 表示在节点 $s_j$ 上部署的成本。

#### 约束3：边缘节点计算资源限制
* 每个边缘节点 $s_j$ 的资源消耗不超过其最大可用资源。
  $$
  \sum_{i=1}^{n} x_{ij} ⋅ r_{i}^{cpu} \leq R_j^{cpu\_max} , \forall s_j \in S
  $$

  $$
  \sum_{i=1}^{n} x_{ij} ⋅ r_{i}^{mem} \leq R_j^{mem\_max} , \forall s_j \in S
  $$

  $$
  \sum_{i=1}^{n} x_{ij} ⋅ r_{i}^{b} \leq R_j^{b\_max} , \forall s_j \in S
  $$

  其中，$R_j^{cpu\_max}$、$R_j^{mem\_max}$、$R_j^{b\_max}$ 分别为边缘节点 $s_j$ 的 $CPU$ 、内存和带宽的最大可用资源。

#### 约束4：用户与服务器的连接
* 每个用户 $u_i$ 必须连接到唯一一个服务器：
  $$
  \sum_{j=1}^{m} x_{ij} = 1, \forall u_i \in U
  $$
  确保每个用户的请求分配到一个最近或者响应时间最优的服务器上。




## 3. 网络拓扑的随机生成

初始阶段需要**随机生成一个网络拓扑结构**，包括用户的分布和服务器的分布。为后续算法优化提供一个初始解和实验环境。

### **3.1 用户分布的随机生成**
- 假设用户分布在一个二维平面上，可以用坐标表示：
  - **用户数量**：设定用户数量 $n$。
  - **位置生成**：在给定区域（例如 $100 \times 100$ 平方公里）内，随机生成用户坐标：
    $$
    u_i = (x_i, y_i), \quad x_i, y_i \in [0, 100]
    $$
  * **用户的请求数据大小 $D_i$**: 个用户随机生成一个值，每个用户的请求大小会随着拓扑生成动态变化
  $$
  D_i \sim \text{Uniform}(0.5, 15) \, \text{MB/s}
  $$ 
 
  * **用户优先级 $Q_i$**：在生成用户时，为每个用户随机分配一个优先级（但我们会预先设定一个**不同优先级用户的比例关系**，符合优先级越高的用户数量越少的规律）：
  $$
  Q_i \sim \text{Uniform}(1, 3)
  $$  

  * **用户权重 $W_i$**：人为设定，可调整？
  * 
### **3.2 服务器分布的随机生成**
- 服务器分布包括边缘节点和云节点：
  - **服务器数量**：设定服务器数量 $m$，其中一部分为边缘服务器 $S_{\text{edge}}$，一部分为云服务器$S_{\text{cloud}}$。
  - **边缘节点的位置**：随机生成在用户分布范围内的坐标，例如：
    $$
    s_j^{\text{edge}} = (x_j, y_j), \quad x_j, y_j \in [0, 100]
    $$
  - **云节点的位置**：通常在中心化的位置，或者固定在远离用户分布的区域。例如：
    $$
    s_j^{\text{cloud}} = (x_j, y_j), \quad x_j, y_j \in [200, 300]
    $$
  - **服务器资源限制**（如 CPU、内存、带宽）：可为每台服务器在拓扑生成时随机分配。例如：
    $$
     R_j^{\text{cpu\_max}} \sim \text{Uniform}(4, 8) \, \text{核（边缘）}, \quad R_j^{\text{cpu\_max}} \sim \text{Uniform}(16, 64) \, \text{核（云）}
    $$

### **3.3 用户与服务器的初始连接**
- 每个用户随机选择一个距离最近的服务器进行初始连接：
  - 计算每个用户与所有服务器的欧几里得距离：
    $$
    d_{ij} = \sqrt{(x_i - x_j)^2 + (y_i - y_j)^2}
    $$
  - 根据距离选择连接：
    $$
    x_{ij} = 
    \begin{cases}
    1, & \text{用户 } u_i \text{ 连接到服务器 } s_j \text{（最近服务器且资源充足）}\\
    0, & \text{否则}
    \end{cases}
    $$
即： 
- 首先选择最近距离的服务器：
    $$ 
    s_j = \arg \min_{j \in S} d_{ij}
    $$
- 检查 $s_j$ 的当前资源是否足够：
    $$
    R_j^{\text{cpu}} \geq r_i^{\text{cpu}}, \quad R_j^{\text{mem}} \geq r_i^{\text{mem}}, \quad R_j^{\text{b}} \geq r_i^{\text{b}}
    $$
- 如果资源不足，选择次优的服务器，循环检查，直到分配完成。


## 4. 初始值设定
### 4.1 用户请求相关的初始值
- **请求数据大小 $D_i$**：生成初始拓扑结构时已生成。  
  
- **传输延迟距离**：根据初始拓扑结构计算。

- **带宽延迟**：
  - 边缘节点的带宽 $b_e(t)$：可设为 100 - 500 Mbps。
  - 云节点的带宽 $b_c(t)$：设为 500 - 1000 Mbps，因其往往资源更充足。

- **传输速度**：
  - 边缘节点的传输速度 $v_e$：可设为 10 - 20 km/ms。
  - 云节点的传输速度 $v_c$：通常较低，可设为 5 - 10 km/ms。

### 4.2 服务器资源相关的初始值
- **处理速率**：
  - 边缘节点的处理速率$P_j^e$：设为 200 - 500 处理单位/秒，表示资源有限。
  - 云节点的处理速率$P_j^c$：设为 800 - 1200 处理单位/秒，表示资源更为充足。

- **服务器资源限制**：
  - **CPU 限制**：边缘节点通常资源较少，可设为 4 - 8 核；云节点可设为 16 - 64 核。
  - **内存限制**：边缘节点设为 8 - 16 GB，云节点设为 32 - 128 GB。
  - **带宽限制**：边缘节点可设为 100 - 500 Mbps，云节点设为 500 - 1000 Mbps。

### 4.3 成本相关的初始值
- **边缘节点的部署成本** $c_j^e$：可以将固定租赁成本设为每小时 40元-70元，资源消耗成本为 CPU 每核心 0.07 元/秒，内存每 GB 0.04 元/秒，带宽每 Mbps 0.015 元/秒。
- **云节点的部署成本** $c_j^c$：云节点的资源消耗成本通常较高，可设定 CPU 每核心 0.15 元/秒，内存每 GB 0.07 元/秒，带宽每 Mbps 0.03 元/秒。

- **流量传输费用**：  
  云节点的网络流量成本 $p_{net}^c$ 通常较高，可设定为每 MB 数据传输 0.07 元。

### 4.4 响应时间目标和预算
* **加权响应时间初始化**：在计算每个用户与服务器连接的初始响应时间 $t_{ij}$ 后，立即计算加权响应时间：
  $$
   t_{ij}^{\text{weight}} = t_{ij} \cdot W_i
  $$
- **最大允许平均响应时间 $T_{max}$**：根据用户体验要求和应用需求设置。可以设定在 200 - 500 ms 范围内。
- **边缘和云预算**：将总预算设定为一个参考值，约￥35000/天；其中边缘预算设为 ￥15000/天，云预算设为 ￥20000/天。

### 4.5 计算初始公平性
在生成初始拓扑后，基于当前的 $t_{ij}^{\text{weight}}$ 计算 Jain 公平性指数：
$$
  F_{\text{Jain}} = \frac{\left( \sum_{i=1}^{n} t_{ij}^{\text{weight}} \right)^2}{n \cdot \sum_{i=1}^{n} \left(t_{ij}^{\text{weight}}\right)^2}
$$
- **评估初始分布的公平性：**
  输出初始公平性指数 $F_{\text{Jain}}$，用于后续优化的参考  



## 5.基于遗传算法的公平性优化
### 5.1 初始化
**1. 输入参数**
* $n$：用户数量。
* $m$：服务器数量。
* $D_i$：用户$u_i$的数据请求大小。
* $Q_i$：用户$u_i$的优先级。
* $W_i$：优先级为$Q_i$的用户的权重。
* $R_j^{\text{cpu\_max}}, R_j^{\text{mem\_max}}, R_j^{\text{b\_max}}$：服务器$s_j$的资源上限（CPU、内存、带宽）。
* $t_{ij}$：用户$u_i$与服务器 $s_j$ 的综合响应时间（包含传输和处理延迟）
* $c_j$：服务器$s_j$的部署成本。
* $C_{max}$：总预算限制。
* $T_{\text{max}}$：最大允许的平均响应时间。
* 遗传算法参数：
  * $P$：种群大小。
  * $G_{\text{max}}$：最大迭代次数。
  * $P_c$：交叉概率。
  * $P_m$：变异概率。

**2. 定义种群**
*  种群 $P$：由 $P$ 个解 $X$ 组成，每个解表示一个可能的部署方案。
* 解$X$：一个 $n \times m$的矩阵，其中：
  $$
  X[i][j] = 
  \begin{cases} 
  1, & \text{表示用户 } u_i \text{ 连接到服务器 } s_j \\ 
  0, & \text{否则}
  \end{cases}
  $$
* 确保每个解满足以下基本约束：
  $$
  \sum_{j=1}^{m} X[i][j] = 1, \quad \forall i \in \{1, 2, \dots, n\}
  $$ 

**3. 种群初始化**  
初始解基于用户与最近服务器的连接规则生成：
$$
     s_j = \arg \min_{j \in S} d_{ij}.
$$

**4. 检查约束**
* 确保资源限制条件不被违反：
    $$
     \sum_{i=1}^{n} X[i][j] \cdot r_{i}^{\text{cpu}} \leq R_j^{\text{cpu\_max}}, \quad \forall j \in S
    $$
    $$
     \sum_{i=1}^{n} X[i][j] \cdot r_{i}^{\text{mem}} \leq R_j^{\text{mem\_max}}, \quad \forall j \in S
    $$
    $$
     \sum_{i=1}^{n} X[i][j] \cdot r_{i}^{b} \leq R_j^{\text{b\_max}}, \quad \forall j \in S
    $$

* 检查总预算限制：
    $$
     \sum_{j=1}^m \text{Active}(s_j) \cdot c_j \leq C_{\text{max}},
     $$
     其中：
     $$
     \text{Active}(s_j) = 
     \begin{cases} 
     1, & \text{若有用户连接到 } s_j \\ 
     0, & \text{否则}.
     \end{cases}
     $$

* 如果上述条件不满足，重新调整该解，直到所有约束被满足。

**4. 初始化记录**
* 设置当前代数 $G = 0$。
* 初始化最优解 $X^*$ 为种群中适应度值最高的个体。

### 5.2 适应度函数
**1. 目标函数**：基于 Jain 公平性指数的最小化目标：
$$
f(X) = 1 - F_{\text{Jain}}
$$
**2. 适应度值计算**：
   - 若满足所有约束：
     $$
      \text{Fitness}(X) = -f(X) = -(1 - F_{\text{Jain}})
     $$
   - 若不满足约束：
     $$
     \text{Fitness}(X) = -10^6.
     $$

### **5.3 遗传算法流程**

1. **初始化种群**：
   - 定义种群大小 $P$，用户数量 $n$，服务器数量 $m$；
   - 随机生成 $P$ 个解，每个解 $X$ 满足用户唯一连接约束：
     $\sum_{j=1}^{m} X[i][j] = 1, \quad \forall i \in \{1, 2, \dots, n\}$。
   * **初始公平性计算**：对每个解 $X$，计算加权响应时间 $t_{ij}^{\text{weight}} = t_{ij} \cdot Q_i$ 和 Jain 公平性指数：
    $$
     F_{\text{Jain}} = \frac{\left( \sum_{i=1}^{n} t_{ij}^{\text{weight}} \right)^2}{n \cdot \sum_{i=1}^{n} \left(t_{ij}^{\text{weight}}\right)^2}.
    $$
  * **约束校验**：检查生成的初始解是否满足约束条件

1. **迭代过程**：
   - 初始化当前代数 $G = 0$。

   While $G < G_{\text{max}}$:
   
   a. **选择操作**：
      - 使用锦标赛选择：从种群中随机选取两组解，保留适应度值较高的解进入下一代。

   b. **交叉操作**：
      - 对父代中的每对个体，以概率 $P_c$ 进行单点交叉，生成两个子代。
      - 交叉规则：
        - 随机选择分界点 $p$；
        - 子代 1：从父代 1 复制前 $p$ 个用户的连接，后 $n-p$ 个用户从父代 2 复制；
        - 子代 2：相反操作。

   c. **变异操作**：
      - 对子代中的每个解，以概率 $P_m$ 执行变异。
      - 变异规则：
        - 随机选择一个用户 $u_i$，重新分配其服务器 $s_j$。
        - 确保变异后仍满足唯一连接约束：
          $$
          \sum_{j=1}^m X[i][j] = 1.
          $$

   d. **修正操作**：
      - 修正不满足约束的解：
        1. **资源超限修正**：优先减少连接到资源超限服务器的用户数量，重新分配到次优服务器。
        2. **预算超限修正**：优先停用高成本服务器，重新分配用户。
        3. **响应时间超限修正**：优先调整超限用户到延迟更短的服务器。  
   
    e. **适应度计算**：
      - 目标函数：
        $$
        f(X) = 1 - F_{\text{Jain}}.
        $$
      - 若满足所有约束：
        $$
        \text{Fitness}(X) = -f(X).
        $$
      - 若不满足约束：
        $$
        \text{Fitness}(X) = -10^6.
        $$  

   f. **更新种群**：
      - 将修正后的子代替换当前种群；
      - 保留当前最优解 $X^*$ 和 $F_{\text{Jain}}^*$。

   g. **代数更新**：  
      $G = G + 1$。

---

### **5.4 输出最优解**
1. **返回最优解 $X^*$：**
   - **连接关系：** 输出每个用户 $u_i$ 与服务器 $s_j$ 的连接关系。
   - **公平性指数：** 输出优化后的 Jain 公平性指数 $F_{\text{Jain}}^*$。
   - **约束条件校验：** 确保最优解满足所有约束条件：
     - 平均响应时间$T_{\text{avg}} \leq T_{\text{max}}$。
     - 部署成本 $C_{\text{total}} \leq C_{\text{max}}$。
     - 服务器资源未超限。

2. **性能对比：**
   - 优化前后公平性指数对比：
     - 初始公平性指数 $F_{\text{Jain}}^{\text{init}}$。
     - 最优解公平性指数 $F_{\text{Jain}}^*$。
   - 优化前后加权响应时间分布对比：
     - 每个用户的$t_{ij}^{\text{weight}}$ 分布统计。

3. **部署结果：**
   - **服务器激活情况：** 输出哪些服务器被激活，激活的用户数量。
   - **资源利用率：** 各服务器的资源使用情况（CPU、内存、带宽）。

4. **总体性能指标：**
   - **平均响应时间 $T_{\text{avg}}$：**
     $$
     T_{\text{avg}} = \frac{1}{n} \sum_{i=1}^n \sum_{j=1}^m X[i][j] \cdot t_{ij}.
     $$
   - **总部署成本 $C_{\text{total}}$：**
     $$
     C_{\text{total}} = \sum_{j \in S_{\text{edge}}} c_j^e + \sum_{j \in S_{\text{cloud}}} c_j^c.
     $$


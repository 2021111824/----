### 贪心+模拟退火算法

#### 模拟退火算法（SA）

*  是一种 **全局优化算法**，用于在 **大规模搜索空间中寻找最优解**，特别适用于 **避免局部最优解的问题**。
* 它的核心思想来源于**物理学中的退火过程**：
  * **高温** 时，**金属原子** 处于高能状态，可以自由移动，寻找稳定结构。
  * **逐渐降温**，原子**缓慢排列**，最终形成**最稳定（最低能量）结构**。
  * **如果降温过快**，原子会陷入不稳定状态（局部最优）。

* 模拟退火算法 **借鉴了这一过程**，在搜索最优解时：

  * **初期** 允许接受较差解，以跳出局部最优。

  * **后期** 降低接受差解的概率，最终收敛到**全局最优解**

  

#### 模拟退火算法步骤

##### 1. 初始化

* 设定一个 **初始解 `current_solution`**。
* 计算该解的 **目标函数值 `current_score`**。
* 设定 **初始温度 `T0`** 和 **降温速率 `alpha`**。
* 设定 **最大迭代次数 `max_iters`**。

##### 2. 迭代优化

**在 `max_iters` 轮优化中：**

1. **随机产生一个新解 `new_solution`**（通常是对 `current_solution` 进行小幅度修改）。
2. 计算该解的 **目标函数值 `new_score`**。
3. 计算 能量差 `delta = new_score - current_score`：
   * **如果 `new_score` 比 `current_score` 好（`delta > 0`）**，直接接受新解。
   * 否则，以一定的概率  `P = exp(delta / T)` 接受较差解：
     * **`T` 大时（高温阶段）**，可以接受较差解，防止局部最优。
     * **`T` 小时（低温阶段）**，只接受较好的解，逐步收敛。
4. **逐渐降低温度**：`T = alpha * T`。

##### 3. 终止条件

* 达到 `max_iters` 。

* `T` 下降到某个**足够低**的阈值。

* 经过多轮迭代 **没有更优解** 产生（提前终止）。



#### 公式解析

##### 1. **Metropolis 准则**（决定是否接受较差解）：

$$
P = e^{\frac{\Delta E}{T}}
$$

其中：

* $ \Delta E = \text{new-score} - \text{current-score} $（能量变化，等同于优化目标值的变化）

* T 为当前温度
* $\frac{\Delta E}{T}$ 是接受概率

解释：

* 在 **高温阶段**：

  * `T` **较大**，`exp(delta / T)` 接近 `1`，即使 `delta` 为负值，仍有较高概率接受新解（探索新区域）。

  在 **低温阶段**：

  * `T` **较小**，`exp(delta / T)` 接近 `0`，算法逐渐只接受更优解，收敛到最优解。



##### 2. **温度衰减（Cooling Schedule）**：

$$
T = \alpha \cdot T
$$

* $\alpha$ 是降温因子（一般取 `0.95 ~ 0.99`）
* 每次迭代后，降低温度，使系统逐步收敛。









# 贪心+模拟退火算法的命名

这个算法结合了 **贪心策略** 和 **模拟退火优化**，主要目标是 **最大化加权 Jain 指数，确保公平性与高效资源分配**。可以考虑以下命名方案：

### **Greedy Simulated Annealing Fairness Optimization (GSAFO)**

* **Greedy**（贪心）：初始分配用户到服务器
* **Simulated Annealing**（模拟退火）：优化分配方案
* **Fairness Optimization**（公平性优化）：最大化 Jain 指数





# 算法时间复杂度分析

### 1. **`calculate_weighted_jain_index`** 函数的复杂度分析

这个函数用于计算加权 Jain 公平性指数，主要计算每个用户的加权响应时间并进行平方和操作。

#### 复杂度分析：

* **循环**: 对每个用户 `i`（共有 `n` 个用户）进行迭代，每次迭代都需要：

  * 查找用户的服务器分配。
  * 计算响应时间。
  * 进行加权计算。

  因此，这一部分的复杂度是 **O(n)**。

* **最终操作**: 对所有响应时间求和和平方，因此也是 **O(n)**。

总的来说，`calculate_weighted_jain_index` 的时间复杂度为 **O(n)**。

### 2. **`greedy_algorithm`** 函数的复杂度分析

贪心算法的核心是根据用户的优先级选择最优的服务器，并在此基础上计算加权 Jain 公平性指数。

#### 复杂度分析：

* **排序**: 对用户的优先级进行排序，这需要 **O(n log n)** 的时间复杂度。
* **服务器选择**: 对每个用户进行服务器选择，并为每个用户计算加权 Jain 公平性指数。对于每个用户（共有 `n` 个），我们需要遍历所有 `m_edge + m_cloud = m` 个服务器，计算加权 Jain 公平性指数并更新分配方案。此步骤的时间复杂度为 **O(m \* n)**。

因此，`greedy_algorithm` 的总时间复杂度为：
$$
O(n \log n + m \cdot n) = O(m \cdot n)
$$


因为 `m` 和 `n` 都可能较大，`O(m * n)` 是主导项。

### 3. **`local_optimization`** 函数的复杂度分析

模拟退火算法的优化过程通过在每次迭代中进行交换（swap）或重新分配（reassign）来寻找解空间中的最优解。

#### 复杂度分析：

* **初始化计算**: 首先计算当前分配的加权 Jain 公平性指数，复杂度为 **O(n)**。
* **循环迭代**: 最大迭代次数为 `max_iters`（假设为常数）。每次迭代中，执行以下操作：
  * **随机选择操作**: 选择交换操作（交换两个用户的服务器分配）或重新分配操作（随机重新分配一个用户）。对于交换操作，我们需要检查两个用户的服务器是否相同并进行交换，复杂度为 **O(1)**。对于重新分配操作，需要检查约束并选择新的服务器，复杂度为 **O(m)**。
  * **约束检查**: 每次交换或重新分配后，检查是否满足约束。约束检查的复杂度为 **O(n)**，因为需要遍历所有用户的服务器分配并检查约束条件。
  * **计算加权 Jain 指数**: 每次新的分配都会重新计算加权 Jain 公平性指数，复杂度为 **O(n)**。

因此，每次迭代的复杂度为 **O(m + n)**，而最大迭代次数为 `max_iters`（假设为常数）。

总的来说，`local_optimization` 的时间复杂度为：

O(max_iters⋅(m+n))=O(m⋅n)O(max\_iters \cdot (m + n)) = O(m \cdot n)

因为 `max_iters` 是常数，复杂度由 `m` 和 `n` 主导。

### 总体时间复杂度

考虑到以上分析，以下是每个函数的主要时间复杂度：

* `calculate_weighted_jain_index`：**O(n)**
* `greedy_algorithm`：**O(m \* n)**
* `local_optimization`：**O(m \* n)**

因此，整个算法的最坏时间复杂度是由贪心算法和模拟退火的优化部分主导的，最终的总时间复杂度为：
$$
O(m \cdot n)
$$


### 空间复杂度分析

空间复杂度主要由存储各个数组（例如用户到服务器的分配矩阵、服务器计算能力、约束检查等）决定。

* `individual`: 用户与服务器的分配矩阵，大小为 `n * m`，占用 **O(n \* m)** 的空间。
* `server_compute_capability`: 服务器计算能力，大小为 `m`，占用 **O(m)** 的空间。
* 其他中间变量（例如计算出的加权 Jain 公平性指数）在内存中占用较少空间。

因此，空间复杂度为：
$$
O(n \cdot m)
$$




### 总结

* **时间复杂度**：`O(m * n)`，其中 `m` 是服务器数量，`n` 是用户数量。
* **空间复杂度**：`O(n * m)`，用于存储服务器分配和相关计算。

这个算法在服务器和用户数量都比较大的情况下，可能会出现性能瓶颈。为了提升性能，可以考虑进一步优化算法，例如并行计算、采用更高效的数据结构（例如堆、优先队列等）。
